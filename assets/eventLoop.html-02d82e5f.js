import{_ as l,W as t,X as r,Y as e,Z as i,$ as o,a0 as n,C as s}from"./framework-805f0bea.js";const p={},c=e("h1",{id:"event-loop-浏览器",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#event-loop-浏览器","aria-hidden":"true"},"#"),i(" Event-Loop (浏览器)")],-1),h={href:"https://juejin.cn/post/6844903692898942990",target:"_blank",rel:"noopener noreferrer"},d=n('<p>首先我们了解一下进程和线程的概念和关系：</p><ul><li>进程：运行的程序就是一个进程，比如你正在运行的浏览器，它会有一个进程；</li><li>线程：程序中独立运行的代码段。一个进程 由单个或多个 线程 组成，线程是负责执行代码的。</li></ul><p>单线程与多线程的区别：</p><ul><li>单线程：从头执行到尾，一行行执行，如果其中一行代码报错，那么剩下的代码将不再执行。同时容易代码阻塞。</li><li>多线程：代码运行的环境不同，各线程独立，互不影响，避免阻塞。 为了保证 JavaScript 的主要运行环境（浏览器），JavaScript 被设计成了单线程语言。</li></ul><p>为了充分利用多核处理器的计算能力，HTML5 提出了 Web Worker 标准，允许 JavaScript 脚本创建多个子线程，但是子线程完全受控于主线程，且不得操作 DOM。因此，新标准并没有改变 JavaScript 单线程的本质。</p><h2 id="执行栈、任务队列" tabindex="-1"><a class="header-anchor" href="#执行栈、任务队列" aria-hidden="true">#</a> 执行栈、任务队列</h2><p>在上图中，主线程运行的时候，产生 堆（heap） 和 栈（stack），栈中的代码调用各种 API，他们在 任务队列 中加入各种事件（DOM Event，ajax，setTimeout...），只要栈中的代码执行完毕，主线程就会去读取任务队列，依次执行那些时间对应的回调函数。</p><ul><li><p>堆（heap）：对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。</p></li><li><p>执行栈（stack）：运行同步代码。执行栈中的代码（同步任务），总是在读取 任务队列（异步任务）之前执行。</p></li><li><p>任务队列（callback queue）：</p></li></ul><p>任务队列 是一个事件的队列（也可以理解成消息的队列），IO 设备完成一项任务，就在 任务队列 中添加一个事件，表示相关的异步任务可以进入 执行栈 了。主线程读取 任务队列，就是读取里面有哪些事件。</p><p>任务队列 中的事件，除了 IO 设备的事件外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等）。只要指定过回调函数，这些事件发生时就会进入 任务队列，等待主线程读取。</p><p>所谓 回调函数（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p><p>任务队列 是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本是自动的，只要执行栈一清空。任务队列 上第一位的事件就自动进入主线程。但是由于存在后文提到的 定时器 功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间才能返回主线程。</p><h2 id="同步任务、异步任务、宏任务、微任务" tabindex="-1"><a class="header-anchor" href="#同步任务、异步任务、宏任务、微任务" aria-hidden="true">#</a> 同步任务、异步任务、宏任务、微任务</h2><p>单线程即意味着所有人物都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就必须一直等着。</p><h2 id="同步任务、异步任务" tabindex="-1"><a class="header-anchor" href="#同步任务、异步任务" aria-hidden="true">#</a> 同步任务、异步任务</h2><p>为此，JavaScript 设计者在广义上将所有任务分成两种：同步任务（synchronous）、异步任务（asynchronous），运行机制如下：</p><ol><li>所有同步任务都在主线程上执行，形成一个 执行栈；</li><li>主线程外，还存在一个 任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件；</li><li>一旦执行栈中所有同步任务执行完毕，系统就会取出任务队列中事件对应的回调函数进入执行栈，开始执行；</li><li>主线程不断重复上面的第三部。</li></ol><h2 id="宏任务、微任务" tabindex="-1"><a class="header-anchor" href="#宏任务、微任务" aria-hidden="true">#</a> 宏任务、微任务</h2><p>除了广义上的定义，我们将任务进行更精细的定义，分为：</p><ul><li>宏任务（macro-task）</li></ul><p>包括整体代码 script，setTimeout，setInterval，ajax，dom操作</p><ul><li>微任务（micro-task）</li></ul><p>Promise</p><p>运行机制如下：</p><ol><li>首先将执行栈最开始的所有同步代码（宏任务）执行完成；</li><li>检查是否有微任务，如有则执行所有微任务；</li><li>取出任务队列中事件对应的回调函数（宏任务）进入执行栈并执行完成；</li><li>再检查是否有微任务，如有则执行所有的微任务；</li><li>主线程不断重复上面的 3、4 步。</li></ol><h2 id="promise" tabindex="-1"><a class="header-anchor" href="#promise" aria-hidden="true">#</a> Promise</h2><p>Promise 相对来说比较特殊，在 new Promise() 中传入的回调函数是会 立即执行 的，但是它的 then() 方法是在 执行栈之后，任务队列之前 执行的，它属于 微任务。</p><h2 id="优先级" tabindex="-1"><a class="header-anchor" href="#优先级" aria-hidden="true">#</a> 优先级</h2><ol><li>同步任务（宏任务）</li><li>process.nextTick</li><li>Promise（微任务）</li><li>setTimeout(fn)、setInterval(fn) （宏任务）</li><li>setimmediate（宏任务）</li><li>setTimeout(fn, time)、setInterval(fn, time) time &gt;0</li></ol>',29);function u(m,_){const a=s("ExternalLinkIcon");return t(),r("div",null,[c,e("blockquote",null,[e("p",null,[i("本文来源："),e("a",h,[i("全方位了解 Javascript 的 Event Loop"),o(a)])])]),d])}const v=l(p,[["render",u],["__file","eventLoop.html.vue"]]);export{v as default};
