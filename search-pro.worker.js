const f=(e,s)=>{const n=e.toLowerCase(),o=s.toLowerCase(),a=[];let l=0,r=0;const u=(t,p=!1)=>{let c="";r===0?c=t.length>20?`… ${t.slice(-20)}`:t:p?c=t.length+r>100?`${t.slice(0,100-r)}… `:t:c=t.length>20?`${t.slice(0,20)} … ${t.slice(-20)}`:t,c&&a.push(c),r+=c.length,p||(a.push(["strong",s]),r+=s.length,r>=100&&a.push(" …"))};let i=n.indexOf(o,l);if(i===-1)return null;for(;i>=0;){const t=i+o.length;if(u(e.slice(l,i)),l=t,r>100)break;i=n.indexOf(o,l)}return r<100&&u(e.slice(l),!0),a};function $(e){return e}const h=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},d="__vueuse_ssr_handlers__";h[d]=h[d]||{};var g;(function(e){e.UP="UP",e.RIGHT="RIGHT",e.DOWN="DOWN",e.LEFT="LEFT",e.NONE="NONE"})(g||(g={}));var m=Object.defineProperty,y=Object.getOwnPropertySymbols,C=Object.prototype.hasOwnProperty,w=Object.prototype.propertyIsEnumerable,I=(e,s,n)=>s in e?m(e,s,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[s]=n,N=(e,s)=>{for(var n in s||(s={}))C.call(s,n)&&I(e,n,s[n]);if(y)for(var n of y(s))w.call(s,n)&&I(e,n,s[n]);return e};const Q={easeInSine:[.12,0,.39,0],easeOutSine:[.61,1,.88,1],easeInOutSine:[.37,0,.63,1],easeInQuad:[.11,0,.5,0],easeOutQuad:[.5,1,.89,1],easeInOutQuad:[.45,0,.55,1],easeInCubic:[.32,0,.67,0],easeOutCubic:[.33,1,.68,1],easeInOutCubic:[.65,0,.35,1],easeInQuart:[.5,0,.75,0],easeOutQuart:[.25,1,.5,1],easeInOutQuart:[.76,0,.24,1],easeInQuint:[.64,0,.78,0],easeOutQuint:[.22,1,.36,1],easeInOutQuint:[.83,0,.17,1],easeInExpo:[.7,0,.84,0],easeOutExpo:[.16,1,.3,1],easeInOutExpo:[.87,0,.13,1],easeInCirc:[.55,0,1,.45],easeOutCirc:[0,.55,.45,1],easeInOutCirc:[.85,0,.15,1],easeInBack:[.36,0,.66,-.56],easeOutBack:[.34,1.56,.64,1],easeInOutBack:[.68,-.6,.32,1.6]};N({linear:$},Q);const b=Object.entries,v=Object.keys,E=e=>e.reduce((s,{type:n})=>s+(n==="title"?50:n==="heading"?20:n==="custom"?10:1),0),_=(e,s)=>{var n;const o={};for(const[a,l]of b(s)){const r=((n=s[a.replace(/\/[^\\]*$/,"")])==null?void 0:n.title)||"",u=`${r?`${r} > `:""}${l.title}`,i=f(l.title,e);i&&(o[u]=[...o[u]||[],{type:"title",path:a,display:i}]),l.customFields&&b(l.customFields).forEach(([t,p])=>{p.forEach(c=>{const O=f(c,e);O&&(o[u]=[...o[u]||[],{type:"custom",path:a,index:t,display:O}])})});for(const t of l.contents){const p=f(t.header,e);p&&(o[u]=[...o[u]||[],{type:"heading",path:a+(t.slug?`#${t.slug}`:""),display:p}]);for(const c of t.contents){const O=f(c,e);O&&(o[u]=[...o[u]||[],{type:"content",header:t.header,path:a+(t.slug?`#${t.slug}`:""),display:O}])}}}return v(o).sort((a,l)=>E(o[a])-E(o[l])).map(a=>({title:a,contents:o[a]}))},P=JSON.parse("{\"/\":{\"/intro.html\":{\"title\":\"介绍页\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"将你的个人介绍和档案放置在此处。\"]}]},\"/devEnv/nvm.html\":{\"title\":\"Nvm 安装与使用\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"nvm 是一个 nodejs 的版本管理工具。通过它可以安装和切换不同版本的 nodejs，解决 node 各种版本存在不兼容现象。\"]},{\"header\":\"卸载Node (没有安装可跳过此步骤)\",\"slug\":\"卸载node-没有安装可跳过此步骤\",\"contents\":[\"一定要确保卸载windows上的Nodejs。\",\"在控制面版或者应用列表中卸载nodejs\",\"不行就全局搜索然后删除相关文件\"]},{\"header\":\"下载Nvm\",\"slug\":\"下载nvm\",\"contents\":[\"下载地址\",\"我的电脑为win11，该版本可正常使用。\",\"安装包\"]},{\"header\":\"安装Nvm\",\"slug\":\"安装nvm\",\"contents\":[\"下载完成后，解压获得exe程序双击运行。\",\"选择同意安装协议\",\"安装协议\",\"Nvm安装路径，会包含所有之后下载的Node版本\",\"安装路径\",\"Nodejs存储路径，存放当前使用的Node\",\"存储路径\",\"点击install，等待安装完成\",\"安装\"]},{\"header\":\"安装Node\",\"slug\":\"安装node\",\"contents\":[\"使用管理员身份运行cmd，一定要使用管理员身份!!!\",\"cmd\",\"输入nvm list available 查看所有可供下载的Nodejs版本\",\"node list\",\"输入 nvm install [version] 安装所需的Nodejs版本,version为所需要的版本号\",\"输入 nvm list 查看已安装版本的node\",\"输入 nvm use [version] 切换使用指定的版本的node。\",\"再次输入 nvm list ,如果版本号前带星号则表示切换成功, 或者输入 nvm current 显示当前版本\",\"切换成功\"]},{\"header\":\"更多相关命令\",\"slug\":\"更多相关命令\",\"contents\":[\"nvm list 查看已经安装的版本\",\"nvm list installed 查看已经安装的版本\",\"nvm list available 查看网络可以安装的版本\",\"nvm version 查看当前的版本\",\"nvm install 安装最新版本\",\"nvm nvm use <version> ## 切换使用指定的版本\",\"node nvm ls 列出所有版本 nvm current显示当前版本\",\"nvm alias <name> <version> ## 给不同的版本号添加别名\",\"nvm unalias <name> ## 删除已定义的别名\",\"nvm reinstall-packages <version> ## 在当前版本node环境下，重新全局安装指定版本号的npm包\",\"nvm on 打开nodejs控制\",\"nvm off 关闭nodejs控制\",\"nvm proxy 查看设置与代理\",\"nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 Index of /dist/\",\"nvm npm_mirror [url] 设置或者查看setting.txt中的 npm_mirror,如果不设置的话默认的是： https://github.com/npm/npm/archive/\",\"nvm uninstall <version> 卸载制定的版本\",\"nvm use [version] [arch] 切换制定的node版本和位数\",\"nvm root [path] 设置和查看root路径\"]}],\"customFields\":{\"0\":[\"教程\"],\"1\":[\"Nvm\",\"Node\"]}},\"/start/buildblog.html\":{\"title\":\"使用 vuepress-theme-hope\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文将记录从零开始使用 vuepress-theme-hope 构建属于自己的博客。\"]},{\"header\":\"安装 Node\",\"slug\":\"安装-node\",\"contents\":[\"从官网下载 Node, vuepress-theme-hope支持16的某些版本和18以后的版本，保险起见大家直接下最新的18。 安装完成后再命令行输入 node -v 查看，显示版本号即表示安装成功。 如果需要管理不同版本的Node,可参考 Nvm安装和使用。\"]},{\"header\":\"创建项目\",\"slug\":\"创建项目\",\"contents\":[\"在命令行窗口运行\",\"命令中的dir是一个参数，使用真实的目录名替换。也可以使用 pnpm 或者 yarn,我使用的是pnpm。 初始化过程中会有一些选项让你选择,包管理器选择pnpm,项目类型blog为博客类型网站，docs为文档类型。如果之后你想把网站挂到GitHub Pages上的话，在询问是否创建工作流的地方记得选一下yes。 安装完成后，进入项目文件运行：\"]},{\"header\":\"主页\",\"slug\":\"主页\",\"contents\":[\"使用src目录下的README.md文件来进行配置。\",\"更多的配置可查阅 vuepress-theme-hope 使用文档。\"]},{\"header\":\"项目打包\",\"slug\":\"项目打包\",\"contents\":[\"先使用下面的命令在本地打包，打完的内容在src/.vuepress/dist目录下：\"]}],\"customFields\":{\"0\":[\"教程\"],\"1\":[\"Blog\"]}},\"/start/githubPage.html\":{\"title\":\"Github Pages\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"将博客部署在Github,依赖于创建项目时选择的github workflow工作流。\"]},{\"header\":\"新建仓库\",\"slug\":\"新建仓库\",\"contents\":[\"创建一个public仓库， 名称格式为 <USERNAME>.github.io, 部署完后通过https://<USERNAME>.github.io/这个域名来访问站点。\"]},{\"header\":\"修改配置\",\"slug\":\"修改配置\",\"contents\":[\"在github仓库中点击Settings选项卡，选择Actions下的General,在 Workflow permissions中选择读写权限 Read and write permissions后，点击保存。\",\"Settings\"]},{\"header\":\"代码提交\",\"slug\":\"代码提交\",\"contents\":[\"提交代码，查看Actions选项卡,绿色表示部署成功，如果失败可以点击进去查看详细的报错信息。\",\"Settings\"]},{\"header\":\"设置部署分支\",\"slug\":\"设置部署分支\",\"contents\":[\"打包后的内容位于src/.vuepress/dist/目录下，而项目中的工作流会默认将这个目录的内容推送到一个新的gh-pages 分支，因此我们还需要额外设置部署页面的分支。\",\"点击Settings选项卡下的Pages，在Build and deployment中选择新的分支：\",\"Settings\",\"切换部署分支后项目会自动重新执行一遍工作流，再过上一会就可以使用域名https://<USERNAME>.github.io/来访问页面了。\",\"并且，在以后每次修改完代码并push后，都会自动触发工作流，自动更新页面。\"]}],\"customFields\":{\"0\":[\"教程\"],\"1\":[\"Github\"]}},\"/start/waline.html\":{\"title\":\"Waline\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文将介绍如何在blog中使用Waline评论插件。\"]},{\"header\":\"获取 APP ID 和 APP Key\",\"slug\":\"获取-app-id-和-app-key\",\"contents\":[\"请先 登录 或 注册 LeanCloud 国际版, 进入 控制台 后点击左下角 创建应用。创建应用后进入该应用，选择左下角的 设置 > 应用Key，然后记下 APP ID,APP Key 和 Master Key。\",\"之后点击下方按钮，跳转至 Vercel 进行快速部署。\",\"Vercel\"]},{\"header\":\"配置仓库\",\"slug\":\"配置仓库\",\"contents\":[\"按照要求输入 Vercel 项目名称与 GitHub 仓库名称。Vercel 会基于 waline 模板帮助你新建并初始化该仓库。仓库初始化完毕后，需要在 Environment Variables 中配置 LEAN_ID, LEAN_KEY 和 LEAN_MASTER_KEY 三个环境变量。它们的值分别对应上一步在 LeanCloud 中获得的 APP ID, APP KEY, Master Key。\"]},{\"header\":\"配置主题\",\"slug\":\"配置主题\",\"contents\":[\"设置好环境变量后，点击 Deploy 部署，一两分钟即可部署完成。之后在主题设置中设置 vercel 地址:\"]}],\"customFields\":{\"0\":[\"教程\"],\"1\":[\"Vercel\",\"插件\"]}},\"/exercise/css/bfc.html\":{\"title\":\"BFC\",\"contents\":[{\"header\":\"BFC 是什么\",\"slug\":\"bfc-是什么\",\"contents\":[\"BFC（Block Formatting Context）块级格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\"]},{\"header\":\"形成 BFC 的条件\",\"slug\":\"形成-bfc-的条件\",\"contents\":[\"body根\",\"绝对定位元素 (position 为 fixed 或者 absolute)\",\"浮动元素 (float 不为 none)\",\"overflow 为 visible 以外的值 （hidden, auto, scroll）\",\"display 为以下的值 inline-block, table-cell, flex, table-caption\"]},{\"header\":\"BFC 特性\",\"slug\":\"bfc-特性\",\"contents\":[\"内部的 Box 会在垂直方向一个接一个地放置\",\"Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\",\"每个盒子（块盒与行盒）的 margin box 的左边，与包含块 border box 的左边相接触，即使存在浮动也是如此\",\"BFC 的区域不会与 float box 重叠\",\"BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响外面的元素。反之也是如此\",\"计算 BFC 的高度时，浮动元素也参与计算\"]},{\"header\":\"BFC 的作用\",\"slug\":\"bfc-的作用\",\"contents\":[\"避免外边距塌陷\",\"清除浮动\",\"自适应两栏布局\"]}],\"customFields\":{\"0\":[\"面试\"],\"1\":[\"css\"]}},\"/exercise/javascript/eventLoop.html\":{\"title\":\"Event-Loop (浏览器)\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本文来源：全方位了解 Javascript 的 Event Loop\",\"首先我们了解一下进程和线程的概念和关系：\",\"进程：运行的程序就是一个进程，比如你正在运行的浏览器，它会有一个进程；\",\"线程：程序中独立运行的代码段。一个进程 由单个或多个 线程 组成，线程是负责执行代码的。\",\"单线程与多线程的区别：\",\"单线程：从头执行到尾，一行行执行，如果其中一行代码报错，那么剩下的代码将不再执行。同时容易代码阻塞。\",\"多线程：代码运行的环境不同，各线程独立，互不影响，避免阻塞。 为了保证 JavaScript 的主要运行环境（浏览器），JavaScript 被设计成了单线程语言。\",\"为了充分利用多核处理器的计算能力，HTML5 提出了 Web Worker 标准，允许 JavaScript 脚本创建多个子线程，但是子线程完全受控于主线程，且不得操作 DOM。因此，新标准并没有改变 JavaScript 单线程的本质。\"]},{\"header\":\"执行栈、任务队列\",\"slug\":\"执行栈、任务队列\",\"contents\":[\"在上图中，主线程运行的时候，产生 堆（heap） 和 栈（stack），栈中的代码调用各种 API，他们在 任务队列 中加入各种事件（DOM Event，ajax，setTimeout...），只要栈中的代码执行完毕，主线程就会去读取任务队列，依次执行那些时间对应的回调函数。\",\"堆（heap）：对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。\",\"执行栈（stack）：运行同步代码。执行栈中的代码（同步任务），总是在读取 任务队列（异步任务）之前执行。\",\"任务队列（callback queue）：\",\"任务队列 是一个事件的队列（也可以理解成消息的队列），IO 设备完成一项任务，就在 任务队列 中添加一个事件，表示相关的异步任务可以进入 执行栈 了。主线程读取 任务队列，就是读取里面有哪些事件。\",\"任务队列 中的事件，除了 IO 设备的事件外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等）。只要指定过回调函数，这些事件发生时就会进入 任务队列，等待主线程读取。\",\"所谓 回调函数（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。\",\"任务队列 是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本是自动的，只要执行栈一清空。任务队列 上第一位的事件就自动进入主线程。但是由于存在后文提到的 定时器 功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间才能返回主线程。\"]},{\"header\":\"同步任务、异步任务、宏任务、微任务\",\"slug\":\"同步任务、异步任务、宏任务、微任务\",\"contents\":[\"单线程即意味着所有人物都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就必须一直等着。\"]},{\"header\":\"同步任务、异步任务\",\"slug\":\"同步任务、异步任务\",\"contents\":[\"为此，JavaScript 设计者在广义上将所有任务分成两种：同步任务（synchronous）、异步任务（asynchronous），运行机制如下：\",\"所有同步任务都在主线程上执行，形成一个 执行栈；\",\"主线程外，还存在一个 任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件；\",\"一旦执行栈中所有同步任务执行完毕，系统就会取出任务队列中事件对应的回调函数进入执行栈，开始执行；\",\"主线程不断重复上面的第三部。\"]},{\"header\":\"宏任务、微任务\",\"slug\":\"宏任务、微任务\",\"contents\":[\"除了广义上的定义，我们将任务进行更精细的定义，分为：\",\"宏任务（macro-task）\",\"包括整体代码 script，setTimeout，setInterval，ajax，dom操作\",\"微任务（micro-task）\",\"Promise\",\"运行机制如下：\",\"首先将执行栈最开始的所有同步代码（宏任务）执行完成；\",\"检查是否有微任务，如有则执行所有微任务；\",\"取出任务队列中事件对应的回调函数（宏任务）进入执行栈并执行完成；\",\"再检查是否有微任务，如有则执行所有的微任务；\",\"主线程不断重复上面的 3、4 步。\"]},{\"header\":\"Promise\",\"slug\":\"promise\",\"contents\":[\"Promise 相对来说比较特殊，在 new Promise() 中传入的回调函数是会 立即执行 的，但是它的 then() 方法是在 执行栈之后，任务队列之前 执行的，它属于 微任务。\"]},{\"header\":\"优先级\",\"slug\":\"优先级\",\"contents\":[\"同步任务（宏任务）\",\"process.nextTick\",\"Promise（微任务）\",\"setTimeout(fn)、setInterval(fn) （宏任务）\",\"setimmediate（宏任务）\",\"setTimeout(fn, time)、setInterval(fn, time) time >0\"]}],\"customFields\":{\"0\":[\"面试\"],\"1\":[\"js\",\"Event-Loop\"]}},\"/exercise/javascript/pubSub.html\":{\"title\":\"手写发布订阅模式\",\"contents\":[{\"header\":\"实现思路\",\"slug\":\"实现思路\",\"contents\":[\"需要有一个 map 对象缓存订阅事件\",\"订阅（on）如果存在事件就往 map 里面缓存事件\",\"取消订阅（off）从 map 对象找到订阅事件删除\",\"发布（emit）从 map 对象找到事件去执行就OK\"]}],\"customFields\":{\"0\":[\"面试\"],\"1\":[\"js\",\"手写\"]}},\"/devEnv/\":{\"title\":\"Dev Env\",\"contents\":[]},\"/start/\":{\"title\":\"Start\",\"contents\":[]},\"/exercise/css/\":{\"title\":\"Css\",\"contents\":[]},\"/exercise/\":{\"title\":\"Exercise\",\"contents\":[]},\"/exercise/javascript/\":{\"title\":\"Javascript\",\"contents\":[]}}}");self.onmessage=({data:e})=>{self.postMessage(_(e.query,P[e.routeLocale]))};
//# sourceMappingURL=original.js.map
